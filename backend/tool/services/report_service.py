# backend/tool/services/report_service.py

import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from django.utils import timezone
from django.conf import settings
# Removed Gemini AI imports - using local analysis only
from ..models import (
    SOCReport, SOCReportSection, SecurityDataUpload, 
    AnomalyDetection, DataAccessLog
)
from .data_analysis_service import DataAnalysisService
from .professional_report_generator import ProfessionalReportGenerator

logger = logging.getLogger(__name__)

class SOCReportService:
    """Service for local data analysis-powered SOC report generation"""
    
    def __init__(self):
        # Initialize local analysis services (no external APIs)
        self.analysis_service = DataAnalysisService()
        self.report_generator = ProfessionalReportGenerator()
        
    def generate_report(self, report: SOCReport) -> bool:
        """Generate complete SOC report using local data analysis"""
        try:
            start_time = timezone.now()
            
            # Get data uploads for the report
            data_uploads = list(report.data_uploads.all())
            if not data_uploads:
                logger.error(f"No data uploads found for report {report.id}")
                report.status = 'failed'
                report.save()
                return False
            
            # Perform comprehensive local data analysis
            period_start = datetime.combine(report.report_period_start, datetime.min.time())
            period_end = datetime.combine(report.report_period_end, datetime.max.time())
            
            analysis_data = self.analysis_service.analyze_security_data(
                data_uploads, period_start, period_end
            )
            
            # Generate professional SOC report sections using local analysis
            sections = [
                ('executive_summary', 'Executive Summary', 
                 self.report_generator.generate_executive_summary),
                ('key_findings', 'Key Findings',
                 self.report_generator.generate_key_findings),
                ('monitoring_overview', 'Monitoring Overview',
                 self.report_generator.generate_monitoring_overview),
                ('incident_overview', 'Incident Overview',
                 self.report_generator.generate_incident_overview),
                ('performance_metrics', 'Performance Metrics',
                 self.report_generator.generate_performance_metrics),
                ('threat_landscape', 'Threat Landscape',
                 self.report_generator.generate_threat_landscape),
                ('incident_summary', 'Incident Summary',
                 self.report_generator.generate_incident_summary),
                ('threat_analysis', 'Critical Threat Analysis',
                 self.report_generator.generate_threat_analysis),
                ('remediation_actions', 'Remediation Actions',
                 self.report_generator.generate_remediation_actions),
                ('compliance', 'Compliance Status',
                 self.report_generator.generate_compliance_status),
                ('recommendations', 'Recommendations & Action Items',
                 self.report_generator.generate_recommendations)
            ]
            
            # Generate each section
            for order, (section_type, section_title, generator_func) in enumerate(sections, 1):
                content = generator_func(analysis_data)
                
                # Create or update section
                section, created = SOCReportSection.objects.get_or_create(
                    report=report,
                    section_type=section_type,
                    defaults={
                        'title': section_title,
                        'content': content,
                        'order': order,
                        'is_ai_generated': False  # Generated by local analysis
                    }
                )
                
                if not created:
                    section.content = content
                    section.order = order
                    section.save()
            
            # Generate KPI metrics and charts using local analysis
            kpi_data = self.report_generator.generate_kpi_metrics(analysis_data)
            report.kpi_metrics = kpi_data
            
            # Update report status
            report.status = 'completed'
            report.generated_at = timezone.now()
            report.generation_time = (timezone.now() - start_time).total_seconds()
            report.ai_model_used = 'Local Data Analysis Engine v1.0'
            report.save()
            
            logger.info(f"Successfully generated report {report.id} using local analysis")
            return True
            
        except Exception as e:
            logger.error(f"Error generating report {report.id}: {str(e)}")
            report.status = 'failed'
            report.save()
            return False
    
    def _collect_legacy_report_data(self, report: SOCReport) -> Dict[str, Any]:
        """Legacy method - kept for backward compatibility"""
        # This method is kept for any legacy code that might call it
        # but the new system uses DataAnalysisService directly
        data_uploads = report.data_uploads.all()
        return {
            'report_period': {
                'start': report.report_period_start.strftime('%Y-%m-%d'),
                'end': report.report_period_end.strftime('%Y-%m-%d'),
                'days': (report.report_period_end - report.report_period_start).days
            },
            'data_uploads': data_uploads.count(),
            'total_records': sum(upload.record_count for upload in data_uploads),
            'tool_types': report.tool_types,
            'company_name': report.company_name
        }
    
    def _generate_legacy_section_content(self, section_type: str, title: str, 
                                       data_summary: Dict, report: SOCReport) -> str:
        """Legacy method for generating content - replaced by local analysis"""
        # This method is kept for backward compatibility but not used in new system
        return f"Content for {title} section generated using local data analysis."
    
    def _generate_legacy_kpi_metrics(self, data_summary: Dict, report: SOCReport) -> Dict[str, Any]:
        """Legacy method for generating KPIs - replaced by local analysis"""
        # This method is kept for backward compatibility but not used in new system
        return {
            'legacy_note': 'KPI metrics now generated by local data analysis',
            'key_metrics': {
                'data_sources': data_summary.get('data_uploads', 0),
                'records_analyzed': data_summary.get('total_records', 0),
                'monitoring_days': data_summary.get('report_period', {}).get('days', 0)
            }
        }
    
    def _calculate_avg_detection_time(self, anomalies) -> float:
        """Calculate average detection time for anomalies - legacy method"""
        # Legacy method - detection time now calculated in DataAnalysisService
        return 4.2  # hours
    
    def _format_tool_summary(self, tool_summary: Dict) -> str:
        """Format tool summary - legacy method"""
        lines = []
        for tool, data in tool_summary.items():
            lines.append(f"- {tool.upper()}: {data['uploads']} datasets, {data['records']:,} records, {data.get('anomalies', 0)} anomalies")
        return '\n'.join(lines)
    
    def _format_top_threats(self, threats: List[Dict]) -> str:
        """Format top threats - legacy method"""
        if not threats:
            return "No high-priority threats identified in this period."
        
        lines = []
        for i, threat in enumerate(threats[:5], 1):
            summary = threat.get('summary', 'Unknown threat')
            severity = threat.get('severity', 'Unknown')
            score = threat.get('anomaly_score', 0)
            lines.append(f"{i}. {summary} (Severity: {severity}, Score: {score:.2f})")
        return '\n'.join(lines)

    def export_to_pdf(self, report: SOCReport, file_path: str) -> bool:
        """Export report to PDF format using ReportLab"""
        try:
            from reportlab.lib.pagesizes import letter, A4
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib import colors
            from reportlab.lib.units import inch
            import os
            import re
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            
            # Create document
            doc = SimpleDocTemplate(file_path, pagesize=A4, 
                                  rightMargin=72, leftMargin=72,
                                  topMargin=72, bottomMargin=72)
            
            # Container for the 'Flowable' objects
            elements = []
            
            # Get styles
            styles = getSampleStyleSheet()
            
            # Custom styles
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=24,
                spaceAfter=30,
                alignment=1,  # Center
                textColor=colors.HexColor('#007acc')
            )
            
            heading_style = ParagraphStyle(
                'CustomHeading',
                parent=styles['Heading2'],
                fontSize=16,
                spaceAfter=12,
                textColor=colors.HexColor('#007acc'),
                borderWidth=1,
                borderColor=colors.HexColor('#007acc'),
                borderRadius=3,
                backColor=colors.HexColor('#f0f8ff'),
                leftIndent=12,
                rightIndent=12,
                spaceBefore=20
            )
            
            # Title page
            elements.append(Paragraph(report.title, title_style))
            elements.append(Spacer(1, 20))
            
            # Report metadata table
            data_summary = report.get_data_summary()
            metadata = [
                ['Report Information', ''],
                ['Report Type', report.report_type.replace('_', ' ').title()],
                ['Report Period', f'{report.report_period_start} to {report.report_period_end}'],
                ['Created Date', report.created_at.strftime('%B %d, %Y at %I:%M %p')],
                ['Generated By', report.created_by.username],
                ['Company', report.company_name],
                ['', ''],
                ['Data Summary', ''],
                ['Total Records Analyzed', f'{data_summary.get("total_records", 0):,}'],
                ['Data Sources', str(data_summary.get("total_uploads", 0))],
                ['Security Tools', ', '.join(data_summary.get("tool_types", []))],
            ]
            
            if report.description:
                metadata.append(['Description', report.description])
            
            metadata_table = Table(metadata, colWidths=[2.5*inch, 4*inch])
            metadata_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (1, 0), colors.HexColor('#007acc')),
                ('TEXTCOLOR', (0, 0), (1, 0), colors.white),
                ('FONTNAME', (0, 0), (1, 0), 'Helvetica-Bold'),
                ('BACKGROUND', (0, 7), (1, 7), colors.HexColor('#007acc')),
                ('TEXTCOLOR', (0, 7), (1, 7), colors.white),
                ('FONTNAME', (0, 7), (1, 7), 'Helvetica-Bold'),
                ('BACKGROUND', (0, 1), (0, 6), colors.HexColor('#f0f8ff')),
                ('BACKGROUND', (0, 8), (0, -1), colors.HexColor('#f0f8ff')),
                ('FONTNAME', (0, 1), (0, -1), 'Helvetica-Bold'),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                ('SPAN', (0, 6), (1, 6))  # Empty row
            ]))
            elements.append(metadata_table)
            elements.append(PageBreak())
            
            # Add sections
            if report.sections.exists():
                for section in report.sections.all().order_by('order'):
                    elements.append(Paragraph(section.title, heading_style))
                    elements.append(Spacer(1, 12))
                    
                    # Process content - handle markdown-like formatting
                    content = section.content
                    
                    # Split into paragraphs
                    paragraphs = content.split('\n\n')
                    
                    for paragraph in paragraphs:
                        if not paragraph.strip():
                            continue
                            
                        lines = paragraph.strip().split('\n')
                        
                        # Handle lists
                        in_list = False
                        for line in lines:
                            line = line.strip()
                            if not line:
                                if in_list:
                                    elements.append(Spacer(1, 6))
                                    in_list = False
                                continue
                            
                            # Clean line of markdown
                            clean_line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', line)
                            clean_line = re.sub(r'^#+\s*', '', clean_line)
                            
                            if line.startswith('- ') or line.startswith('• '):
                                clean_line = '• ' + clean_line[2:]
                                elements.append(Paragraph(clean_line, styles['Normal']))
                                in_list = True
                            else:
                                if in_list:
                                    elements.append(Spacer(1, 6))
                                    in_list = False
                                elements.append(Paragraph(clean_line, styles['Normal']))
                                elements.append(Spacer(1, 4))
                        
                        if not in_list:
                            elements.append(Spacer(1, 8))
                    
                    elements.append(Spacer(1, 20))
                    
                    # Add page break between major sections
                    if section.section_type in ['executive_summary', 'monitoring_overview', 'incident_summary']:
                        elements.append(PageBreak())
            
            # Build PDF
            doc.build(elements)
            
            logger.info(f"Successfully exported report {report.id} to PDF: {file_path}")
            return True
            
        except Exception as e:
            logger.error(f"Error exporting report {report.id} to PDF: {str(e)}")
            return False
    
    def export_to_docx(self, report: SOCReport, file_path: str) -> bool:
        """Export report to Word document format using python-docx"""
        try:
            from docx import Document
            from docx.shared import Inches, Pt
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            from docx.enum.style import WD_STYLE_TYPE
            import os
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            
            # Create document
            doc = Document()
            
            # Add title
            title = doc.add_heading(report.title, 0)
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            # Add report metadata
            doc.add_paragraph(f"Report Type: {report.report_type.replace('_', ' ').title()}")
            doc.add_paragraph(f"Report Period: {report.report_period_start} to {report.report_period_end}")
            doc.add_paragraph(f"Created: {report.created_at.strftime('%B %d, %Y')}")
            doc.add_paragraph(f"Generated by: {report.created_by.username}")
            
            if report.description:
                doc.add_paragraph(f"Description: {report.description}")
            
            # Add page break
            doc.add_page_break()
            
            # Add data summary
            doc.add_heading('Data Summary', level=1)
            data_summary = report.get_data_summary()
            
            summary_table = doc.add_table(rows=1, cols=2)
            summary_table.style = 'Table Grid'
            
            hdr_cells = summary_table.rows[0].cells
            hdr_cells[0].text = 'Metric'
            hdr_cells[1].text = 'Value'
            
            metrics = [
                ('Total Records Analyzed', f"{data_summary['total_records']:,}"),
                ('Data Sources', str(data_summary['total_uploads'])),
                ('Tool Types', ', '.join(data_summary['tool_types'])),
                ('Report Period', f"{data_summary['date_range']['start']} to {data_summary['date_range']['end']}")
            ]
            
            for metric, value in metrics:
                row_cells = summary_table.add_row().cells
                row_cells[0].text = metric
                row_cells[1].text = value
            
            doc.add_paragraph()  # Add space
            
            # Add KPI metrics if available
            if hasattr(report, 'kpi_metrics') and report.kpi_metrics:
                doc.add_heading('Key Performance Indicators', level=1)
                
                if 'key_metrics' in report.kpi_metrics:
                    metrics = report.kpi_metrics['key_metrics']
                    for key, value in metrics.items():
                        p = doc.add_paragraph()
                        p.add_run(f"{key.replace('_', ' ').title()}: ").bold = True
                        p.add_run(str(value))
            
            # Add sections
            sections = report.sections.all().order_by('order')
            for section in sections:
                doc.add_heading(section.title, level=1)
                
                # Add content paragraphs
                content_paragraphs = section.content.split('\n\n')
                for paragraph_text in content_paragraphs:
                    if paragraph_text.strip():
                        doc.add_paragraph(paragraph_text.strip())
                
                # Add space after section
                doc.add_paragraph()
            
            # Add footer information
            doc.add_page_break()
            doc.add_heading('Report Generation Information', level=1)
            doc.add_paragraph(f"This report was generated automatically using AI analysis.")
            doc.add_paragraph(f"AI Model: {report.ai_model_used}")
            if report.generation_time:
                doc.add_paragraph(f"Generation Time: {report.generation_time:.2f} seconds")
            doc.add_paragraph(f"Generated on: {timezone.now().strftime('%B %d, %Y at %I:%M %p')}")
            
            # Save document
            doc.save(file_path)
            
            logger.info(f"Successfully exported report {report.id} to DOCX: {file_path}")
            return True
            
        except Exception as e:
            logger.error(f"Error exporting report {report.id} to DOCX: {str(e)}")
            return False
    
    def _generate_html_content(self, context: dict) -> str:
        """Generate HTML content for PDF export"""
        report = context['report']
        sections = context['sections']
        
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>{report.title}</title>
        </head>
        <body>
            <div class="header">
                <h1>{report.title}</h1>
                <p><strong>Report Type:</strong> {report.report_type.replace('_', ' ').title()}</p>
                <p><strong>Period:</strong> {report.report_period_start} to {report.report_period_end}</p>
                <p><strong>Generated:</strong> {context['creation_date'].strftime('%B %d, %Y')}</p>
            </div>
            
            <div class="section">
                <h2 class="section-title">Data Summary</h2>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-value">{context['data_summary']['total_records']:,}</div>
                        <div>Records Analyzed</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">{context['data_summary']['total_uploads']}</div>
                        <div>Data Sources</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value">{len(context['data_summary']['tool_types'])}</div>
                        <div>Tools Monitored</div>
                    </div>
                </div>
                <p><strong>Tools:</strong> {', '.join(context['data_summary']['tool_types'])}</p>
            </div>
        """
        
        # Add KPI metrics if available
        if hasattr(report, 'kpi_metrics') and report.kpi_metrics:
            if 'key_metrics' in report.kpi_metrics:
                html += '<div class="section"><h2 class="section-title">Key Performance Indicators</h2>'
                html += '<div class="metrics-grid">'
                
                for key, value in report.kpi_metrics['key_metrics'].items():
                    html += f"""
                    <div class="metric-card">
                        <div class="metric-value">{value}</div>
                        <div>{key.replace('_', ' ').title()}</div>
                    </div>
                    """
                
                html += '</div></div>'
        
        # Add sections
        for section in sections:
            safe_content = section.content.replace("\n", "<br>")
            html += f"""
            <div class="section">
                <h2 class="section-title">{section.title}</h2>
                <div>
                    {safe_content}
                </div>
            </div>
            """
        
        html += """
            <div class="section">
                <h2 class="section-title">Report Generation Information</h2>
                <p>This report was generated automatically using AI analysis.</p>
                <p><strong>AI Model:</strong> """ + report.ai_model_used + """</p>
        """
        
        if report.generation_time:
            html += f"<p><strong>Generation Time:</strong> {report.generation_time:.2f} seconds</p>"
        
        html += f"""
                <p><strong>Generated on:</strong> {context['creation_date'].strftime('%B %d, %Y at %I:%M %p')}</p>
            </div>
        </body>
        </html>
        """
        
        return html